/** @param {NS} ns **/

const factionList = [
	/* basic factions */
	"CyberSec",
	"Tian Di Hui",
	"Netburners",
	"NiteSec",
	"The Black Hand",
	"BitRunners",
];

const locationFactionList = [
	"Sector-12",
	"Chongqing",
	"New Tokyo",
	"Ishima",
	"Aevum",
	"Volhaven",
];

const gangList = [
	"Slum Snakes",
	"Tetrads",
	"Silhouette",
	"Speakers for the Dead",
	"The Dark Army",
	"The Syndicate",
];

const endgameFactionList = [
	"The Covenant",
	"Daedalus",
	"Illuminati",
];

const aug_bonus_types = {
	hack: ["hacking_mult", "hacking_exp_mult", "hacking_speed_mult"],
	faction: ["faction_rep_mult"],
	company: ["company_rep_mult"],
	crime: ["crime_success_mult", "crime_money_mult"]
};

const augs_to_ignore = [
	"NeuroFlux Governor",
	"The Red Pill",
];

export function main(ns) {
	const flagdata = ns.flags([
		["factions", false],
		["locations", false],
		["gangs", false],
		["endgame", false],
		["all", false],
		["faction", ""],
		["help", false],
		["type", ["all"]]
	])
	let factions_to_consider = [];
	let types_to_consider = [];
	if (flagdata.help) {
		ns.tprint(
			`Pass in any of: --factions, --locations, --gangs, --endgame; or --all for factions. Use --faction X for a specific faction.
			   --type can be: ${Object.keys(aug_bonus_types).join(", ")} or all`
		);
		return
	}
	// If they didn't pass in a valid type, yell
	if (!flagdata.type == "all" && !Object.keys(aug_bonus_types).some(items => flagdata.type.includes(items))) {
		ns.tprint("you dun goofed");
		return
	}
	const pattern = [
		[data => { return data.factions || data.all }, () => factions_to_consider.push(...factionList)],
		[data => { return data.locations || data.all }, () => factions_to_consider.push(...locationFactionList)],
		[data => { return data.gangs || data.all }, () => factions_to_consider.push(...gangList)],
		[data => { return data.endgame || data.all }, () => factions_to_consider.push(...endgameFactionList)],
		[data => { return data.faction }, (data) => { factions_to_consider.push(data.faction) }],
		[data => { return data.type }, (data) => { (data.type == "all" ? types_to_consider.push(Object.keys(aug_bonus_types)) : types_to_consider.push(data.type)) }],
	]
	for (const [condition, action] of pattern) {
		if (condition(flagdata)) action(flagdata)
	}
	// Build the map of possible augs
	let aug_map = buildAugMap(ns, factions_to_consider);
	// ns.tprint([...aug_map.entries()]);
	// Map the shorthand type arguments to actual aug stats we want
	let aug_stat_types = getStatsFromTypes(ns, types_to_consider.flat());
	// Now let's take a look at the rep requirements, and costs...
	let desired_augs = filterAugsByStats(ns, aug_map, aug_stat_types)
}

/**
 * Build up a map of augmentations available everywhere for future slicing
 * @param ns
 * @param {array} factions_to_consider A list of factions to search through 
 */
function buildAugMap(ns, factions_to_consider) {
	// ns.tprint(`Factions to consider: ${factions_to_consider}`);
	let aug_map = new Map();
	// Keys: augmentation name; Values: an object aug_model = {"factions": [], "repreq": 0, "cost": 0};
	// Now get all augs matching multipliers
	for (const faction of factions_to_consider) {
		let avail_augs = ns.getAugmentationsFromFaction(faction).filter(item => !augs_to_ignore.includes(item));
		for (const aug of avail_augs) {
			// ns.tprint(`Considering ${aug} from ${faction}`)
			// Don't care about the infinitely-upgrading Governor
			if (aug == "NeuroFlux Governor") continue
			// Get the stats, and cost
			let aug_stats = ns.getAugmentationStats(aug);
			let repreq = ns.getAugmentationRepReq(aug);
			let cost = ns.getAugmentationPrice(aug);
			// Add to the list of factions already found for a given aug
			let augs_factions = [];
			if (aug_map.has(aug)) {
				augs_factions = aug_map.get(aug)["factions"];
			}
			augs_factions.push(faction);
			aug_map.set(aug, { "factions": augs_factions, "repreq": repreq, "cost": cost, "stats": aug_stats });
		}
	}
	return aug_map;
}

/** 
 * Return a list of augs filtered by stats
 * @param ns
 * @param {map} aug_map Map of all augmentations generated by buildAugMap()
 * @param {array} desired_stats A list of stats to search for 
 */
function filterAugsByStats(ns, aug_map, desired_stats) {
	let desired_augs = [];
	// Get my augs first
	let my_augs = ns.getOwnedAugmentations(true);
	// Brute force it:
	for (let [aug, model] of aug_map.entries()) {
		// Filter out my already installed augs
		if (my_augs.includes(aug)) continue
		/*
		 * Basic filtering code:
		 * desired_stats = ["hacking_exp_mult", "hacking_money_mult"]
		 * Object.keys(item["stats"]) = ["hacking_mult", "hacking_exp_mult", "hacking_speed_mult"]
		 * let matches = desired_stats.filter( items => actual_stats.includes(items) );
		 */
		// Look for matching stats
		let matching_stats = desired_stats.filter(items => Object.keys(model["stats"]).includes(items));
		if (matching_stats.length > 0) {
			desired_augs.push(aug)
			ns.tprint(`${aug} from [${model["factions"].join(", ")}]: ${matching_stats.join(", ")}`);
		}
	}
	return desired_augs
}

/**
 * Return a list of aug stats from the passed in types
 * @param ns
 * @param {array} types Shorthand types passed in to ns.flags
 */
function getStatsFromTypes(ns, types) {
	let stat_list = [];
	for (let type of types) {
		stat_list.push(aug_bonus_types[type]);
	}
	return stat_list.flat()
}

/**
 * Print out a list of aug goals by faction
 *  
 */
function printToDoList(aug_map) {

}

// function printCheckbox(condition, label) {
//   return `[${!!condition ? 'x' : ' '}] ${label}`
// }